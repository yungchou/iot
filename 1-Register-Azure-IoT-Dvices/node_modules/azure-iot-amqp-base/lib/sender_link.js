"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var machina = require("machina");
var dbg = require("debug");
var events_1 = require("events");
var azure_iot_common_1 = require("azure-iot-common");
var debug = dbg('azure-iot-amqp-base:SenderLink');
/**
 * @private
 * State machine used to manage AMQP sender links
 *
 * @extends {EventEmitter}
 * @implements {AmqpLink}
 */
/*Codes_SRS_NODE_AMQP_SENDER_LINK_16_002: [The `SenderLink` class shall inherit from `EventEmitter`.]*/
/*Codes_SRS_NODE_AMQP_SENDER_LINK_16_003: [The `SenderLink` class shall implement the `AmqpLink` interface.]*/
var SenderLink = /** @class */ (function (_super) {
    __extends(SenderLink, _super);
    function SenderLink(linkAddress, linkOptions, amqp10Client) {
        var _this = _super.call(this) || this;
        _this._linkAddress = linkAddress;
        _this._linkOptions = linkOptions;
        _this._amqp10Client = amqp10Client;
        _this._unsentMessageQueue = [];
        _this._pendingMessageQueue = [];
        _this._detachHandler = function (detachEvent) {
            debug('handling detach event: ' + JSON.stringify(detachEvent));
            _this._fsm.handle('forceDetach', detachEvent.error);
        };
        _this._errorHandler = function (err) {
            debug('handling error event: ' + err.toString());
            _this._fsm.handle('forceDetach', err);
        };
        var pushToQueue = function (message, callback) {
            _this._unsentMessageQueue.push({
                message: message,
                callback: callback
            });
        };
        _this._fsm = new machina.Fsm({
            initialState: 'detached',
            namespace: 'senderlink',
            states: {
                detached: {
                    _onEnter: function (callback, err) {
                        _this._linkObject = null;
                        debug('link detached: ' + _this._linkAddress);
                        debug('unsent message queue length: ' + _this._unsentMessageQueue.length);
                        /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_021: [If the link fails to attach and there are messages in the queue, the callback for each message shall be called with the error that caused the detach in the first place.]*/
                        if (_this._unsentMessageQueue.length > 0) {
                            var messageCallbackError = err || new Error('Link Detached');
                            debug('dequeuing and failing unsent messages');
                            var unsent = _this._unsentMessageQueue.shift();
                            while (unsent) {
                                unsent.callback(messageCallbackError);
                                unsent = _this._unsentMessageQueue.shift();
                            }
                        }
                        debug('pending message queue length: ' + _this._pendingMessageQueue.length);
                        /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_014: [If the link is detached while a message is being sent, the `callback` shall be called with an `Error` object describing the AMQP error that caused the detach to happen in the first place.]*/
                        if (_this._pendingMessageQueue.length > 0) {
                            debug('dequeuing and failing pending messages');
                            var messageCallbackError = err || new Error('Link Detached');
                            var pending = _this._pendingMessageQueue.shift();
                            while (pending) {
                                debug('failing pending message with error: ' + messageCallbackError.toString());
                                pending.callback(messageCallbackError);
                                pending = _this._pendingMessageQueue.shift();
                            }
                        }
                        if (callback) {
                            /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_018: [If an error happened that caused the link to be detached while trying to attach the link or send a message, the `callback` for this function shall be called with that error.]*/
                            callback(err);
                        }
                        else if (err) {
                            /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_016: [If an error happened that caused the link to be detached, the sender link shall call emit an `error` event with that error.]*/
                            _this.emit('error', err);
                        }
                    },
                    /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_011: [If the state machine is not in the `attached` state, the `SenderLink` object shall attach the link first and then send the message.]*/
                    attach: function (callback) { return _this._fsm.transition('attaching', callback); },
                    detach: function (callback) {
                        debug('detach: link already detached');
                        callback();
                    },
                    forceDetach: function () {
                        /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_026: [The `forceDetach` method shall return immediately if the link is already detached.]*/
                        debug('forceDetach: link already detached');
                        return;
                    },
                    send: function (message, callback) {
                        pushToQueue(message, callback);
                        _this._fsm.handle('attach');
                    }
                },
                attaching: {
                    _onEnter: function (callback) {
                        /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_004: [The `attach` method shall use the stored instance of the `amqp10.AmqpClient` object to attach a new link object with the `linkAddress` and `linkOptions` provided when creating the `SenderLink` instance.]*/
                        debug('creating sender with amqp10 for: ' + _this._linkAddress);
                        _this._amqp10Client.createSender(_this._linkAddress, _this._linkOptions)
                            .then(function (amqp10link) {
                            debug('sender object created by amqp10 for endpoint: ' + _this._linkAddress);
                            if (_this._fsm.state === 'attaching') {
                                _this._linkObject = amqp10link;
                                /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_006: [The `SenderLink` object should subscribe to the `detached` event of the newly created `amqp10` link object.]*/
                                _this._linkObject.on('detached', _this._detachHandler);
                                /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_007: [The `SenderLink` object should subscribe to the `errorReceived` event of the newly created `amqp10` link object.]*/
                                _this._linkObject.on('errorReceived', _this._errorHandler);
                                _this._fsm.transition('attached', callback);
                            }
                            else {
                                debug('client forceDetached us already - cleaning up');
                                amqp10link.forceDetach();
                            }
                            return null;
                        })
                            .catch(function (err) {
                            debug('amqp10 failed to create sender: ' + err.toString());
                            _this._fsm.transition('detached', callback, err);
                        });
                    },
                    detach: function (callback) { return _this._fsm.transition('detaching', callback); },
                    forceDetach: function (err) {
                        if (_this._linkObject) {
                            _this._removeListeners();
                            /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_025: [The `forceDetach` method shall call the `forceDetach` method on the underlying `amqp10` link object.]*/
                            _this._linkObject.forceDetach();
                        }
                        _this._fsm.transition('detached', undefined, err);
                    },
                    send: function (message, callback) { return pushToQueue(message, callback); }
                },
                attached: {
                    _onEnter: function (callback) {
                        debug('link attached. processing unsent message queue');
                        var toSend = _this._unsentMessageQueue.shift();
                        while (toSend) {
                            debug('got message from unsent queue');
                            _this._fsm.handle('send', toSend.message, toSend.callback);
                            toSend = _this._unsentMessageQueue.shift();
                        }
                        if (callback)
                            callback();
                    },
                    attach: function (callback) { return callback(); },
                    detach: function (callback) { return _this._fsm.transition('detaching', callback); },
                    forceDetach: function (err) {
                        if (_this._linkObject) {
                            _this._removeListeners();
                            /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_025: [The `forceDetach` method shall call the `forceDetach` method on the underlying `amqp10` link object.]*/
                            _this._linkObject.forceDetach();
                        }
                        _this._fsm.transition('detached', undefined, err);
                    },
                    send: function (message, callback) {
                        var op = {
                            message: message,
                            callback: callback
                        };
                        debug('pushing message to pending queue');
                        _this._pendingMessageQueue.push(op);
                        /*Codes_SRS_NODE_COMMON_AMQP_16_011: [All methods should treat the `done` callback argument as optional and not throw if it is not passed as argument.]*/
                        var _processPendingMessageCallback = function (error, result) {
                            var opIndex = _this._pendingMessageQueue.indexOf(op);
                            if (opIndex >= 0) {
                                _this._pendingMessageQueue.splice(opIndex, 1);
                                if (op.callback) {
                                    /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_013: [If the message is successfully sent, the `callback` shall be called with a first parameter (error) set to `null` and a second parameter of type `MessageEnqueued`.]*/
                                    /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_012: [If the message cannot be sent the `callback` shall be called with an `Error` object describing the AMQP error reported by the service.]*/
                                    process.nextTick(function () { return op.callback(error, result); });
                                }
                            }
                        };
                        debug('sending message using underlying amqp10 link object');
                        /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_010: [The `send` method shall use the link created by the underlying `amqp10.AmqpClient` to send the specified `message` to the IoT hub.]*/
                        _this._linkObject.send(message)
                            .then(function (state) {
                            debug('message sent successfully');
                            _processPendingMessageCallback(null, new azure_iot_common_1.results.MessageEnqueued(state));
                            return null;
                        })
                            .catch(function (err) {
                            debug('error sending message');
                            _processPendingMessageCallback(err);
                        });
                    }
                },
                detaching: {
                    _onEnter: function (callback, err) {
                        /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_023: [The `detach` method shall call the `callback` with the original `Error` that caused the detach whether it succeeds or fails to cleanly detach the link.]*/
                        if (_this._linkObject) {
                            /*Codes_SRS_NODE_AMQP_SENDER_LINK_16_009: [** The `detach` method shall detach the link created by the `amqp10.AmqpClient` underlying object.]*/
                            _this._removeListeners();
                            _this._linkObject.detach().then(function () {
                                _this._fsm.transition('detached', callback, err);
                            }).catch(function (err) {
                                debug('error detaching the sender link: ' + err.toString());
                                _this._fsm.transition('detached', callback, err);
                            });
                        }
                        else {
                            _this._fsm.transition('detached', callback, err);
                        }
                    },
                    '*': function () { return _this._fsm.deferUntilTransition('detached'); }
                }
            }
        });
        _this._fsm.on('transition', function (transition) {
            debug(transition.fromState + ' -> ' + transition.toState + ' (action:' + transition.action + ')');
        });
        return _this;
    }
    SenderLink.prototype.detach = function (callback) {
        this._fsm.handle('detach', callback);
    };
    SenderLink.prototype.forceDetach = function (err) {
        this._fsm.handle('forceDetach', err);
    };
    SenderLink.prototype.attach = function (callback) {
        this._fsm.handle('attach', callback);
    };
    SenderLink.prototype.send = function (message, callback) {
        this._fsm.handle('send', message, callback);
    };
    SenderLink.prototype._removeListeners = function () {
        this._linkObject.removeListener('detached', this._detachHandler);
        this._linkObject.removeListener('errorReceived', this._errorHandler);
    };
    return SenderLink;
}(events_1.EventEmitter));
exports.SenderLink = SenderLink;
//# sourceMappingURL=sender_link.js.map