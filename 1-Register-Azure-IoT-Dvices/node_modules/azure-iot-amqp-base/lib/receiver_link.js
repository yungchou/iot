"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var machina = require("machina");
var dbg = require("debug");
var events_1 = require("events");
var azure_iot_common_1 = require("azure-iot-common");
var amqp_message_1 = require("./amqp_message");
var debug = dbg('azure-iot-amqp-base:ReceiverLink');
/**
 * @private
 * State machine used to manage AMQP receiver links
 *
 * @extends {EventEmitter}
 * @implements {AmqpLink}
 */
/*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_002: [** The `ReceiverLink` class shall inherit from `EventEmitter`.]*/
/*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_003: [** The `ReceiverLink` class shall implement the `AmqpLink` interface.]*/
var ReceiverLink = /** @class */ (function (_super) {
    __extends(ReceiverLink, _super);
    function ReceiverLink(linkAddress, linkOptions, amqp10Client) {
        var _this = _super.call(this) || this;
        _this._linkAddress = linkAddress;
        _this._linkOptions = linkOptions;
        _this._amqp10Client = amqp10Client;
        _this._detachHandler = function (detachEvent) {
            debug('handling detach event: ' + JSON.stringify(detachEvent));
            _this._fsm.handle('forceDetach', detachEvent.error);
        };
        _this._errorHandler = function (err) {
            debug('handling error event: ' + err.toString());
            _this._fsm.handle('forceDetach', err);
        };
        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_012: [If a `message` event is emitted by the `amqp10` link object, the `ReceiverLink` object shall emit a `message` event with the same content.]*/
        _this._messageHandler = function (message) {
            _this.emit('message', amqp_message_1.AmqpMessage.toMessage(message));
        };
        _this._fsm = new machina.Fsm({
            initialState: 'detached',
            namespace: 'receiverlink',
            states: {
                detached: {
                    _onEnter: function (callback, err) {
                        _this._linkObject = null;
                        if (callback) {
                            callback(err);
                        }
                        else if (err) {
                            /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_011: [If a `detached` or `errorReceived` event is emitted by the `amqp10` link object, the `ReceiverLink` object shall forward that error to the client.]*/
                            _this.emit('error', err);
                        }
                    },
                    attach: function (callback) {
                        _this._fsm.transition('attaching', callback);
                    },
                    detach: function (callback) { _this._safeCallback(callback); },
                    forceDetach: function () {
                        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_028: [The `forceDetach` method shall return immediately if the link is already detached.]*/
                        debug('forceDetach: link already detached');
                        return;
                    },
                    accept: function (message, callback) { return callback(new azure_iot_common_1.errors.DeviceMessageLockLostError()); },
                    reject: function (message, callback) { return callback(new azure_iot_common_1.errors.DeviceMessageLockLostError()); },
                    abandon: function (message, callback) { return callback(new azure_iot_common_1.errors.DeviceMessageLockLostError()); }
                },
                attaching: {
                    _onEnter: function (callback) {
                        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_004: [The `attach` method shall use the stored instance of the `amqp10.AmqpClient` object to attach a new link object with the `linkAddress` and `linkOptions` provided when creating the `ReceiverLink` instance.]*/
                        debug('creating receiver with amqp10 for: ' + _this._linkAddress);
                        _this._amqp10Client.createReceiver(_this._linkAddress, _this._linkOptions)
                            .then(function (amqp10link) {
                            debug('receiver object created by amqp10 for endpoint: ' + _this._linkAddress);
                            if (_this._fsm.state === 'attaching') {
                                _this._linkObject = amqp10link;
                                /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_006: [The `ReceiverLink` object should subscribe to the `detached` event of the newly created `amqp10` link object.]*/
                                _this._linkObject.on('detached', _this._detachHandler);
                                /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_007: [The `ReceiverLink` object should subscribe to the `errorReceived` event of the newly created `amqp10` link object.]*/
                                _this._linkObject.on('errorReceived', _this._errorHandler);
                                _this._linkObject.on('message', _this._messageHandler);
                                /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_020: [The `attach` method shall call the `callback` if the link was successfully attached.]*/
                                _this._fsm.transition('attached', callback);
                            }
                            else {
                                debug('client forceDetached us already - cleaning up');
                                amqp10link.forceDetach();
                            }
                            return null;
                        })
                            .catch(function (err) {
                            debug('amqp10 failed to create receiver: ' + err.toString());
                            _this._fsm.transition('detached', callback, err);
                        });
                    },
                    detach: function (callback) { return _this._fsm.transition('detaching', callback); },
                    forceDetach: function (err) {
                        if (_this._linkObject) {
                            _this._removeListeners();
                            _this._linkObject.forceDetach();
                        }
                        _this._fsm.transition('detached', undefined, err);
                    },
                    accept: function (message, callback) { return callback(new azure_iot_common_1.errors.DeviceMessageLockLostError()); },
                    reject: function (message, callback) { return callback(new azure_iot_common_1.errors.DeviceMessageLockLostError()); },
                    abandon: function (message, callback) { return callback(new azure_iot_common_1.errors.DeviceMessageLockLostError()); }
                },
                attached: {
                    _onEnter: function (callback, err) {
                        _this._safeCallback(callback, err);
                    },
                    attach: function (callback) {
                        _this._safeCallback(callback);
                    },
                    detach: function (callback) { return _this._fsm.transition('detaching', callback); },
                    forceDetach: function (err) {
                        if (_this._linkObject) {
                            _this._removeListeners();
                            /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_027: [** The `forceDetach` method shall call the `forceDetach` method on the underlying `amqp10` link object.]*/
                            _this._linkObject.forceDetach();
                        }
                        _this._fsm.transition('detached', undefined, err);
                    },
                    accept: function (message, callback) {
                        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_022: [** The `accept` method shall work whether a `callback` is specified or not, and call the callback with a `result.MessageCompleted` object if a callback is specified.]*/
                        _this._linkObject.accept(message);
                        _this._safeCallback(callback, null, new azure_iot_common_1.results.MessageCompleted());
                    },
                    reject: function (message, callback) {
                        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_023: [** The `reject` method shall work whether a `callback` is specified or not, and call the callback with a `result.MessageRejected` object if a callback is specified.]*/
                        _this._linkObject.reject(message);
                        _this._safeCallback(callback, null, new azure_iot_common_1.results.MessageRejected());
                    },
                    abandon: function (message, callback) {
                        _this._linkObject.release(message);
                        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_024: [** The `abandon` method shall work whether a `callback` is specified or not, and call the callback with a `result.MessageAbandoned` object if a callback is specified.]*/
                        _this._safeCallback(callback, null, new azure_iot_common_1.results.MessageAbandoned());
                    }
                },
                detaching: {
                    _onEnter: function (callback, err) {
                        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_025: [The `detach` method shall call the `callback` with an `Error` that caused the detach whether it succeeds or fails to cleanly detach the link.]*/
                        if (_this._linkObject) {
                            _this._removeListeners();
                            /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_009: [The `detach` method shall detach the link created by the `amqp10.AmqpClient` underlying object.]*/
                            _this._linkObject.detach().then(function () {
                                _this._fsm.transition('detached', callback, err);
                            }).catch(function (err) {
                                debug('error detaching the receiver link: ' + err.toString());
                                _this._fsm.transition('detached', callback, err);
                            });
                        }
                        else {
                            _this._fsm.transition('detached', callback, err);
                        }
                    },
                    '*': function () { return _this._fsm.deferUntilTransition('detached'); }
                }
            }
        });
        _this.on('removeListener', function (eventName) {
            // stop listening for AMQP events if our consumers stop listening for our events
            if (eventName === 'message' && _this.listeners('message').length === 0) {
                _this._fsm.handle('detach');
            }
        });
        _this.on('newListener', function (eventName) {
            // lazy-init AMQP event listeners
            if (eventName === 'message') {
                _this._fsm.handle('attach');
            }
        });
        return _this;
    }
    ReceiverLink.prototype.detach = function (callback) {
        this._fsm.handle('detach', callback);
    };
    ReceiverLink.prototype.forceDetach = function (err) {
        this._fsm.handle('forceDetach', err);
    };
    ReceiverLink.prototype.attach = function (callback) {
        this._fsm.handle('attach', callback);
    };
    ReceiverLink.prototype.accept = function (message, callback) {
        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_021: [The `accept` method shall throw if the `message` argument is falsy.]*/
        if (!message) {
            throw new ReferenceError('Invalid message object.');
        }
        this._fsm.handle('accept', message.transportObj, callback);
    };
    /**
     * @deprecated Use accept(message, callback) instead (to adhere more closely to the AMQP10 lingo).
     */
    ReceiverLink.prototype.complete = function (message, callback) {
        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_015: [The `complete` method shall call the `accept` method with the same arguments (it is here for backward compatibility purposes only).]*/
        this.accept(message, callback);
    };
    ReceiverLink.prototype.reject = function (message, callback) {
        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_021: [The `reject` method shall throw if the `message` argument is falsy.]*/
        if (!message) {
            throw new ReferenceError('Invalid message object.');
        }
        this._fsm.handle('reject', message.transportObj, callback);
    };
    ReceiverLink.prototype.abandon = function (message, callback) {
        /*Codes_SRS_NODE_AMQP_RECEIVER_LINK_16_021: [The `abandon` method shall throw if the `message` argument is falsy.]*/
        if (!message) {
            throw new ReferenceError('Invalid message object.');
        }
        this._fsm.handle('abandon', message.transportObj, callback);
    };
    ReceiverLink.prototype._removeListeners = function () {
        this._linkObject.removeListener('detached', this._detachHandler);
        this._linkObject.removeListener('message', this._messageHandler);
        this._linkObject.removeListener('errorReceived', this._errorHandler);
    };
    ReceiverLink.prototype._safeCallback = function (callback, error, result) {
        if (callback) {
            process.nextTick(function () { return callback(error, result); });
        }
    };
    return ReceiverLink;
}(events_1.EventEmitter));
exports.ReceiverLink = ReceiverLink;
//# sourceMappingURL=receiver_link.js.map